<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../mstyle.css" />
    <script src="../pscripts.js" defer></script>
    <script src="./../../mscripts/loader.js" defer></script>
    <!--math-->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@500&display=swap"
      rel="stylesheet"
    />
    <title>Document</title>
  </head>
  <body>
    <div class="partial" data-path="./../partials/header.html"></div>
    <div id="mySidenav" class="sidenav">
      <a href="javascript:void(0)" class="closebtn">&times;</a>
    </div>
    <div class="divOfBtn">
      <span>&#9776; </span>
    </div>
    <div class="bigt">Grafuri(neorientate)</div>
    <div id="main">
      Introducere:
      <br />
      Grafurile au numeroase aplicații în diverse domenii: proiectarea
      circuitelor electrice, determinarea celui mai scurt drum dintre două
      localități, rețelele sociale (ex. Facebook), etc. Primele rezultate legate
      de teoria grafurilor au fost obținute de matematicianul Leonard Euler, cel
      care a studiat Problema podurilor din Königsberg, din imaginea de mai jos.
      A demonstrat că problema nu are soluție, iar în onoarea lui o categorie
      specială de grafuri au fost numite grafuri euleriene.
      <br /><br /><br />
      <div class="subtitle">Terminologie</div>
      <br />
      Definiție: Se numește graf neorientat o pereche ordonată de mulțimi
      G=(X,U), unde: X este o mulțime finită și nevidă de elemente numite
      vârfuri sau noduri; U este o mulțime finită de submulțimi cu două elemente
      din X, numite muchii. Vom nota în continuare vârfurile cu valori între 1
      și n – unde n este număru de vârfuri din graf, iar muchiile cu [x,y] sau
      (x,y), unde x și y sunt vârfuri și se numesc extremitățile muchiei. Un
      vecin al unui vârf x este orice vârf y cu proprietatea că există muchia
      [x,y]. Două vârfuri între care există muchie se numesc adiacente. Două
      muchii sunt incidente dacă au o o extremitate comună. Un vârf este
      incident cu o muchie dacă vârful este extremitate a acelei muchii.
      Mulțimea muchiilor are proprietatea de simetrie: dacă [x,y] este muchie,
      atunci și [y,x] este muchie. Conform definiției: într-un graf neorientat
      nu există muchie de la un vârf la el însuși; intre două vârfuri distincte
      există cel mult o muchie.
      <i>
        <br />
        Exemplu: Fie G=(X,U), unde: X={1,2,3,4,5,6,7,8,9,10,11}
        U={[1,4],[1,5],[2,3],[2,8],[3,11],[4,5],[4,9],[7,10],[8,11]}
      </i>
      <br /><br />
      <img src="./../images/img1.png" width="300" height="300" />
      <div class="subtitle">Gradul unui vârf</div>
      <b>Definiție</b> Într-un graf neorientat se numește grad al unui vârf
      numărul de vârful adiacente cu acesta (sau numărul de muchii incidente cu
      acesta). Gradul unui vărf x se notează d(x) (degree).
      <br />
      <b>Observatii:</b>
      <ul>
        <li>
          un vârf cu gradul 0 se numește izolat. În graful de mai sus, vârful 6
          este izolat.
        </li>
        <li>
          un vârf cu gradul 1 se numește terminal. În graful de mai sus, vârful
          9 este vârf terminal.
        </li>
        <li>gradul maxim al unui vârf într-un graf cu n vârfuri este n-1.</li>
      </ul>
      <b>Teoremă:</b>
      Într-un graf neorientat, suma gradelor tuturor vârfurilor este dublul
      numărului de muchii.
      <b>Consecințe:</b>
      <ul>
        <li>Suma gradelor tuturor vârfurilor este număr par.</li>
        <li>
          Într-un graf neorientat, numărul de vârfuri de grad impar este
          întotdeauna par.
        </li>
      </ul>
      <div class="subtitle">Reprezentarea grafurilor neorientate</div>
      <b>1.Matricea de adiacență: </b><br />
      Pentru un graf neorientat G=(X,U) cu n vârfuri, matricea de adiacență este
      o matrice cu n linii și n coloane și elemente din {0,1}, cu:
      <math xmlns="http://www.w3.org/1998/Math/MathML">
        <msub>
          <mi>A</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>i</mi>
            <mo>,</mo>
            <mi>j</mi>
          </mrow>
        </msub>
        <mo>=</mo>
        <mrow>
          <mo>{</mo>
          <mtable columnalign="left left" rowspacing="4pt" columnspacing="1em">
            <mtr>
              <mtd>
                <mn>1</mn>
              </mtd>
              <mtd>
                <mstyle displaystyle="false" scriptlevel="0">
                  <mtext>dac&#x103;&#xA0;</mtext>
                </mstyle>
                <mo stretchy="false">[</mo>
                <mi>i</mi>
                <mo>,</mo>
                <mi>j</mi>
                <mo stretchy="false">]</mo>
                <mo>&#x2208;<!-- ∈ --></mo>
                <mi>U</mi>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mstyle displaystyle="false" scriptlevel="0">
                  <mtext>dac&#x103;&#xA0;</mtext>
                </mstyle>
                <mo stretchy="false">[</mo>
                <mi>i</mi>
                <mo>,</mo>
                <mi>j</mi>
                <mo stretchy="false">]</mo>
                <mo>&#x2209;<!-- ∉ --></mo>
                <mi>U</mi>
              </mtd>
            </mtr>
          </mtable>
          <mo fence="true" stretchy="true" symmetric="true"></mo>
        </mrow>
      </math>
      <br />
      Exemplu: <br />
      Pentru graful neorientat de mai jos avem următoarea matrice de adiacență:
      <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mi>A</mi>
        <mo>=</mo>
        <mrow>
          <mo>(</mo>
          <mtable
            columnalign="center center center center center"
            rowspacing="4pt"
            columnspacing="1em"
          >
            <mtr>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>1</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>1</mn>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>1</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>1</mn>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>1</mn>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>1</mn>
              </mtd>
              <mtd>
                <mn>1</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>1</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
            </mtr>
          </mtable>
          <mo>)</mo>
        </mrow>
      </math>
      <br /><br /><br />
      <img src="./../images/img2.JPG" alt="" width="300" height="300" />
      <br /><br />
      <b>2.Lista de muchii</b><br />
      Lista de muchii a unui graf neorientat reprezintă o mulțime ce conține
      toate muchiile din graf. Pentru graful de sus, lista de muchii este:
      U={[1,2],[1,5],[2,5],[4,5]} Pentru reprezentarea în memorie putem folosi:
      <ul>
        <li>un tablou unidimensional cu elemente de tip struct {int I,J;}</li>
        <li>două tablouri unidimensionale cu elemente de tip int</li>
        <li>o listă alocată dinamic</li>
        <li>etc.</li>
      </ul>
      <b>3.Liste de adiacențe (de vecini): </b><br />
      Pentru un graf neorientat cu G=(X,U) se va memora numărul de vârfuri n și
      apoi, pentru fiecare vârf x, lista vârfurilor adiacente cu x, adică a
      vârfurilor y cu proprietatea că există muchia [x,y]. Pentru graful de sus,
      listele de adiacență sunt: <br />
      1: 2 5 <br />
      2: 1 5 <br />
      3: vidă <br />
      4: 5 <br />
      5: 1 2 4 <br />
      La reprezentarea în memorie trebui avut în vedere că dimensiunile listelor
      de vecini sunt variabile. De aceea, este neeficientă utilizarea unor
      tablouri alocate static. Astfel, putem folosi:

      <ul>
        <li>un șir de n tablouri unidimensionale alocate dinamic;</li>
        <li>un șir de n vectori din STL;</li>
        <li>un șir de n liste simplu (dublu) înlănțuite alocate dinamic.</li>
      </ul>
      <div class="subtitle">Graf parțial. Subgraf. Graf complementar</div>
      <b>Definiție:</b> Fie G=(X, U) un graf neorientat. Se numeşte graf parțial
      al grafului G, graful neorientat G1=(X, U1), unde U1 ⊆ U. Din definiție
      rezultă:
      <ul>
        <li>
          Un graf parțial al unui graf neorientat G=(V,U), are aceeaşi mulțime
          de vârfuri ca şi G, iar mulțimea muchiilor este o submulțime a lui U
          sau chiar U.
        </li>
        <li>
          Fie G=(X, U) un graf neorientat. Un graf parțial al grafului G se
          obține păstrând vârfurile şi eliminând eventual nişte muchii (se pot
          elimina şi toate muchiile sau chiar nici una).
        </li>
      </ul>
      <b>Definiție:</b> Fie G=(X, U) un graf orientat. Se numeşte subgraf al
      grafului G graful neorientat G1=(X1,U1) unde X1 ⊆ X iar U1 conține toate
      arcele din U care au extremitățile în X1. <br />
      Din definiție rezultă: <br />
      Fie G=(X,U) un graf orientat. Un subgraf al grafului G, se obține ştergând
      eventual anumite vârfuri şi odată cu acestea şi muchiile care le admit ca
      extremitate (nu se pot şterge toate vârfurile deoarece s-ar obține un graf
      cu mulțimea vârfurilor vidă).
      <img src="./../images/img3.JPG" alt="" />
      <b>Teoremă:</b> Fie G un graf neorientat cu n vârfuri și m muchii. Atunci:
      <ul>
        <li>graful G admite 2^m grafuri parțiale;</li>
        <li>graful G admite 2^(n)–1 subgrafuri;</li>
        <li>graful G admite un unic graf complementar.</li>
      </ul>
      <div class="subtitle">
        Graf nul. Graf complet. Graf regulat. Graf bipartit
      </div>
      <b>Definiție:</b>
      Un graf neorientat se numește graf nul dacă mulțimea muchiilor este vidă.
      <br />
      Într-un graf nul toate vârfurile sunt izolate.
      <br />
      <b>Definiție:</b>
      Fie G=(X, U) un graf neorientat. Graful G se numește graf complet dacă
      oricare două vârfuri distincte ale sale sunt adiacente. Un graf complet cu
      n vârfuri se notează K<small>n</small>.
      <br />
      Exemplu: Graful următor este graful K<small>5</small>.
      <br /><br /><br />
      <img src="./../images/img4.JPG" alt="" />
      <br />
      Într-un graf complet cu n vârfuri sunt
      <math xmlns="http://www.w3.org/1998/Math/MathML">
        <msubsup>
          <mi>C</mi>
          <mi>n</mi>
          <mn>2</mn>
        </msubsup>
        <mo>=</mo>
        <mrow class="MJX-TeXAtom-ORD">
          <mfrac>
            <mrow class="MJX-TeXAtom-ORD">
              <mi>n</mi>
              <mo>&#x2217;<!-- ∗ --></mo>
              <mo stretchy="false">(</mo>
              <mi>n</mi>
              <mo>&#x2212;<!-- − --></mo>
              <mn>1</mn>
              <mo stretchy="false">)</mo>
            </mrow>
            <mn>2</mn>
          </mfrac>
        </mrow>
      </math>
      muchii și fiecare vârf are gradul n-1.
      <br />
      <b>Propoziție:</b><br />
      Sunt
      <math xmlns="http://www.w3.org/1998/Math/MathML">
        <msup>
          <mn>2</mn>
          <mrow class="MJX-TeXAtom-ORD">
            <mfrac>
              <mrow class="MJX-TeXAtom-ORD">
                <mi>n</mi>
                <mo>&#x2217;<!-- ∗ --></mo>
                <mo stretchy="false">(</mo>
                <mi>n</mi>
                <mo>&#x2212;<!-- − --></mo>
                <mn>1</mn>
                <mo stretchy="false">)</mo>
              </mrow>
              <mn>2</mn>
            </mfrac>
          </mrow>
        </msup>
      </math>
      grafuri neorientate distincte cu n vârfuri.
      <b>Definiție:</b>
      Un graf în care toate nodurile au acelaşi grad se numește graf regulat.
      <b>Exemplu:</b><br />
      Graful de mai jos este regulat. <br /><br />
      <img src="./../images/img5.JPG" alt="" />
      <br />
      <b>Definiţie:</b> <br />
      Un graf G=(X, U) se numește graf bipartit dacă există două mulţimi nevide
      A și B astfel încât X=A ∪ B, A ∩ B = ∅ şi orice muchie u a lui G are o
      extremitate în A iar cealaltă în B. Mulţimile A şi B formează o partiţie a
      lui X.
      <br />
      <b>Exemplu:</b>
      <br />Graful următor este bipartit. A={1,2,5,7} și B={3,4,6}.
      <br />
      <img src="./../images/img6.JPG" alt="" />
      <br />
      <b>Definiție:</b><br />
      Un graf bipartit G=(X,U) se numește bipartit complet dacă pentru oricare
      două vârfuri x∈A și y∈B, există în graf muchia [x,y]; adică [x,y]∈U.
      <br />
      <b>Exemplu:</b>
      <br />Graful următor este bipartit complet. <br />
      <img src="./../images/img7.JPG" alt="" />
      <div class="subtitle">Conexitate</div>
      <br />
      <b>Lanț, ciclu</b>
      <br /><b>Definiție:</b>
      Se numește lanț o succesiune de vârfuri L=[x1,x2,⋯xk] cu proprietatea că
      oricare două vârfuri consecutive sunt adiacente.
      <br />
      Se numește lanț o succesiune de vârfuri L=[x1,x2,⋯xk] cu proprietatea că
      oricare două vârfuri consecutive sunt adiacente.
      <br />
      <b>Definiție:</b>
      Se numește ciclu un lanț simplu în care primul vârf este identic cu
      ultimul. Dacă toate vârfurile sunt distincte, mai puțin primul și ultimul,
      se numește ciclu elementar. Lungimea unui ciclu este egală cu numărul de
      muchii din ciclu. Lungimea minimă a unui ciclu este 3. Un ciclu se numește
      par dacă lungimea sa este pară, respectiv impar în caz contrar. Un graf
      neorientat care nu conține niciun ciclu se numește aciclic.
      <br />
      <b>Exemple:</b>
      În graful de mai sus:
      <img src="./../images/img8.JPG" alt="" />
      <ul>
        <li>[2,4,1,3,5,7] este un lanț elementar</li>
        <li>[3,5,7,6,5,1] este un lanț neelementar, dar simplu</li>
        <li>[2,3,5,7,6,5,3,1] este un lanț compus</li>
        <li>[1,5,3,2,4,1] este un ciclu elementar</li>
        <li>[1,3,5,7,6,5,1] este un ciclu neelementar</li>
      </ul>
      <div class="subtitle">Graf conex. Componente conexe</div>
      <br />
      <b> Definiție: </b> Un graf neorientat se numește graf conex dacă pentru
      oricare două vârfuri x și y diferite ale sale, există cel puțin un lanț
      care le leagă, adică x este extremitatea inițială și y este extremitatea
      finală. Un graf cu un singur nod este, prin definiție, conex. Definiție:
      Se numește componentă conexă a unui graf G=(X,U) un subgraf H=(Y, V),
      conex, al lui G care are proprietatea că nu există nici un lanț în G care
      să lege un vârf din Y cu un vârf din X – Y. Subgraful H este conex și
      maximal cu această proprietate (dacă s-ar mai adăuga un vârf nu ar mai fi
      conex.) Un graf este conex dacă admite o singură componentă conexă. <br />
      Graful următor este conex: <br /><br />
      <img src="./../images/img9.JPG" alt="" />
      <br /><br />
      Graful următor nu este conex și are 4 componente conexe. <br />
      <br />
      <img src="./../images/image10.JPG" alt="" />

      <div class="subtitle">Arbore. Pădure</div>
      <b>Definiție:</b>
      Se numește arbore un graf conex și aciclic.
      <b>Exemplu</b>
      Graful următor este arbore:
      <br /><br />
      <img src="./../images/img11.JPG" alt="" />
      <br />
      <b>Observații:</b><br />
      <ul>
        <li>Un arbore cu n vârfuri are n-1 muchii.</li>
        <li>
          Un arbore este un graf conex și minimal cu această proprietate; dacă
          s-ar mai elimina o muchie, graful nu ar mai fi conex.
        </li>
        <li>
          Un arbore este un graf aciclic și maximal cu această proprietate; dacă
          s-ar mai adăuga o muchie, s-ar obține un ciclu.
        </li>
      </ul>
      Un graf parțial care este arbore se numește arbore parțial. Un graf care
      nu conține cicluri se mai numește pădure. Într-o pădure fiecare componentă
      conexă este arbore.
      <div class="subtitle">Graf hamiltonian. Graf eulerian</div>
      <b>Definiție:</b>
      Se numește graf hamiltonian un graf care conține un ciclu hamiltonian. Se
      numește ciclu hamiltonian un ciclu elementar care conține toate vârfurile
      grafului.
      <br />
      Exemplu: Graful următor este hamiltonian. Un ciclu hamiltonian este:
      [1,4,2,3,7,6,5,1]
      <br />
      <img src="./../images/img12.JPG" alt="" />
      <br />
      <b>Teoremă:</b>
      Un G un graf neorientat. Dacă are n≥3 vârfuri şi gradul oricărui vârf
      verifică inegalitatea d(x)≥n/2 atunci G este hamiltonian.
      <br /><b>Definiție:</b> Se numește graf eulerian un graf care conține un
      ciclu eulerian. Se numește ciclu eulerian un ciclu care conține toate
      muchiile grafului. <br />
      Graful următor este eulerian. Un ciclu eulerian este:
      [1,4,2,1,3,2,7,3,5,7,6,5,1] <br />
      <img src="./../images/img13.JPG" alt="" /> <br />
      <b>Teoremă:</b>
      <br />Un graf G = (X,U), fără vârfuri izolate, este eulerian dacă şi numai
      dacă este conex şi gradele tuturor vârfurilor sale sunt numere pare.
      <br />
      <div class="bigt" id="grori">Grafuri orientate</div>
      <br />
      Se numeşte graf orientat sau digraf o pereche ordonată de mulțimi notată
      G=(V, U), unde:
      <br />
      V este o mulțime finită şi nevidă ale cărei elemente se numesc noduri sau
      vârfuri, U este o mulțime de perechi ordonate de elemente distincte din V
      ale cărei elemente se numesc arce;
      <br />
      <img src="./../images/img14.JPG" alt="" />
      <br />
      <b>Notiuni:</b>
      <ul>
        <li>
          extremități ale unui arc: pentru arcul u=(x,y), se numesc extremități
          ale sale nodurile x şi y;
          <ul>
            <li>x se numeşte extremitate inițială;</li>
            <li>y se numeşte extremitate finală;</li>
            <li>y se numește succesor al lui x;</li>
            <li>x se numește predecesor al lui y.</li>
          </ul>
        </li>
        <li>
          vârfuri adiacente: dacă într-un graf există arcul u=(x,y) (sau
          u=(y,x), sau amândouă), se spune despre nodurile x şi y că sunt
          adiacente;
        </li>
        <li>
          incidență:
          <ul>
            <li>
              dacă u1 şi u2 sunt două arce ale aceluiaşi graf, se numesc
              incidente dacă au o extremitate comună. Exemplu: u1=(x,y) şi
              u2=(y,z) sunt incidente;
            </li>
            <li>
              dacă u1=(x,y) este un arc într-un graf, se spune despre el şi
              nodul x, sau nodul y, că sunt incidente.
            </li>
          </ul>
        </li>
      </ul>
      <div class="subtitle">Grade</div>
      <br />
      <b>Definiție:</b>
      Fie G=(V, U) un graf orientat și x un nod al său. <br />
      <ul>
        <li>
          Se numeşte grad exterior al nodului x, numărul arcelor de forma (x,y)
          (adică numărul arcelor care ies din x), notat d+(x).
        </li>
        <li>
          Se numeşte grad interior al nodului x, numărul arcelor de forma (y,x)
          (adică numărul arcelor care intră în x), notat d-(x).
        </li>
      </ul>
      <img src="./../images/img15.JPG" alt="" />
      <br />
      Pentru graful de sus: d+(2)=2, d-(2)=3
      <div class="subtitle">Graf complet. Graf turneu.</div>
      <br />
      Fie G=(V, U) un graf orientat. Graful G se numește graf complet dacă
      oricare două vârfuri distincte ale sale sunt adiacente. <br />
      Două vârfuri x și y sunt adiacente dacă:

      <ul>
        <li>între ele există arcul (x,y), sau</li>
        <li>între ele există arcul (y,x), sau</li>
        <li>între ele există arcele (x,y) şi (y,x).</li>
      </ul>
      <br />
      <img src="./../images/img16.JPG" alt="" />
      <br />
      <b>Teoremă:</b>
      Numărul de grafuri orientate complete cu n noduri este 3^n*(n-1)/2.
      <b>Definiție:</b> Un graf orientat este turneu, dacă oricare ar fi două
      vârfuri i şi j, i≠j, între ele există un singur arc: arcul (i,j) sau arcul
      (j,i).
      <br />
      <img src="./../images/img17.JPG" alt="" />
      <b>Proprietăți:</b>
      <ul>
        <li>Orice graf turneu este graf complet.</li>
        <li>TeAvem 2^n*(n-1)/2 grafuri turneu cu n noduri.a</li>
        <li>
          În orice graf turneu există un drum elementar care trece prin toate
          vârfurile grafului.
        </li>
      </ul>
      <div class="subtitle">Conexitate</div>
      <div class="subtitle">*Lanț. Drum</div>
      Definiție: Fie G=(V, U) un graf orientat. Se numește lanț, în graful G, o
      succesiune de arce, notată L = (u1 , u2 ,..., uk) cu proprietatea ca
      oricare două arce consecutive au o extremitate comună (nu are importanță
      orientarea arcelor). sau Definiție: Fie G=(V, U) un graf orientat. Se
      numește lanț, în graful G, o succesiune de noduri, notată L = (x1 , x2
      ,..., xp) cu proprietatea ca oricare două noduri consecutive sunt
      adiacente. Lungimea unui lanț este egală cu numărul de arce din care este
      alcătuit. Primul nod și ultimul nod dintr-un lanț formează extremitățile
      lanțului. Definiție. Fie G=(V, U) un graf orientat. Se numește drum în
      graful G o succesiune de noduri, notată D = (x1 , x2 ,..., xk), cu
      proprietatea că pentru orice 1 ≤ i &lt k, (xi,xi+1) este arc în G.
      Lungimea unui drum este egală cu numărul de arce din care este alcătuit.
      Pentru un drum D = (x1 , x2 ,..., xk), nodurile x1 și xk reprezintă
      extremitățile – inițială, respectiv finală. Un lanț (drum) se numește
      elementar dacă în el nu se repetă noduri. Un lanț (drum) se numește simplu
      dacă în el nu se repetă arce.
      <div class="subtitle">*Circuit:</div>
      Se numește circuit un drum simplu în care extremitatea inițială și finală
      sunt egale. Se numește circuit elementar un circuit în care, cu excepția
      extremităților, nu se repetă noduri. Lungimea unui circuit este
      reprezentată de numărul de arce din care acesta este alcătuit.
      <br />
      <div class="subtitle">Conexitate. Tare conexitate</div>
      Definiții: Fie G=(V,U) un graf orientat. Graful se numește tare conex dacă
      între oricare două noduri distincte există cel puțin un drum. Se numește
      componentă tare conexă un subgraf tare conex și maximal cu această
      calitate – dacă am mai adauga un nod, n-ar mai fi tare conex. Observație:
      Un nod al grafului face parte dintr-o singură componentă tare conexă. Dacă
      ar face parte din două compoennte tare conexe, ele s-ar “reuni” prin
      intermediul acelui nod.
      <div class="subtitle">Graf hamiltonian. Graf eulerian</div>
      Definiții: Fie un graf orientat G=(V,U). Un drum elementar care conține
      toate nodurile grafului se numește drum hamiltonian. Un circuit elementar
      care conține toate nodurile grafului se numește circuit hamiltonian. Un
      graf care conține un circuit hamiltonian se numește graf hamiltonian.

      <b> Definiții: </b>
      Fie un graf orientat G=(V,U). Un drum care conține toate arcele grafului
      se numește drum eulerian. Un circuit care conține toate arcele grafului se
      numește circuit eulerian. Un graf care conține un circuit eulerian se
      numește graf eulerian. Teoremă: Un graf fără noduri izolate este eulerian
      dacă și numai dacă este conex și pentru fiecare nod, gradul interior este
      egal cu cel exterior. Exemplu: Graful orientat de mai jos este eulerian.
      <br />
      <img src="./../images/img18.JPG" alt="" />
      <br />
      Graful de mai sus nu este tare conex. El conține trei componente tare
      conexe. <br />
      Observație: Un nod al grafului face parte dintr-o singură componentă tare
      conexă. Dacă ar face parte din două compoennte tare conexe, ele s-ar
      “reuni” prin intermediul acelui nod.
      <div class="subtitle">Graf hamiltonian. Graf eulerian</div>
      Definiții: Fie un graf orientat G=(V,U). Un drum elementar care conține
      toate nodurile grafului se numește drum hamiltonian. Un circuit elementar
      care conține toate nodurile grafului se numește circuit hamiltonian. Un
      graf care conține un circuit hamiltonian se numește graf hamiltonian.
      <br />
      Definiții: Fie un graf orientat G=(V,U). Un drum care conține toate arcele
      grafului se numește drum eulerian. Un circuit care conține toate arcele
      grafului se numește circuit eulerian. Un graf care conține un circuit
      eulerian se numește graf eulerian. Teoremă: Un graf fără noduri izolate
      este eulerian dacă și numai dacă este conex și pentru fiecare nod, gradul
      interior este egal cu cel exterior. <br />
      <div class="bigt">Parcurgerea în adâncime</div>
      <br />
      Parcurgerea în adâncime reprezintă explorarea “naturală” a unui graf
      neorientat. Este foarte asemănătoare cu modul în care un turist vizitează
      un oraș în care sunt obiective turistice (vârfurile grafului) și căi de
      acces între obiective (muchiile). Vizitarea orașului va avea loc din
      aproape în aproape: se pleacă de la un obiectiv de pornire, se continuă cu
      un obiectiv învecinat cu acesta, apoi unul învecinat cu al doilea, etc.
      Parcurgerea în adâncime se face astfel:
      <ul>
        <li>
          Se începe cu un vârf inițial x, care este în acest moment vârf curent.
        </li>
        <li>
          Vârful x se vizitează. Se determină primul său vecin nevizitat y al
          lui x, care devine vârf curent.
        </li>
        <li>
          Apoi se vizitează primul vecin nevizitat al lui y, şi aşa mai departe,
          mergând în adâncime, până când ajungem la un vârf care nu mai are
          vecini nevizitați. Când ajungem într-un astfel de vârf, ne întoarcem
          la “părintele” acestuia – vârful din care am ajuns în acesta.
        </li>
        <li>
          Dacă acest vârf mai are vecini nevizitați, alegem următorul vecin
          nevizitat al său și continuam parcurgerea în același mod.
        </li>
        <li>
          Dacă nici acest vârf nu mai are vecini nevizitați, revenim în vârful
          său părinte și continuăm în același mod, până când toate vârfurile
          accesibile din vârful de start sunt vizitate.
        </li>
      </ul>
      Pentru implementarea algoritmului se foloseşte un vector caracteristic
      pentru memorarea faptului că un anume vârf a fost sau nu vizitat, la un
      anumit moment al parcurgerii: Pentru a determina ordinea în care se
      parcurg nodurile care pot fi vizitate, se folosește o stivă: Pentru
      implementare se poate folosi ca stivă memoria STACK, prin intermediul
      recursivității.
      <br />
      <b>Implementare C++: </b>
      <script
        src="https://ideone.com/e.js/9llxQr"
        type="text/javascript"
      ></script>
      <br />
      <div class="bigt">Parcurgerea în lățime</div>
      Se parcurge vârful de start, apoi vecinii acestuia, apoi vecinii
      nevizitați ai acestora, etc, până când sunt vizitate toate vârfurile
      accesibile. Practic, pentru a stabili ordinea de vizitare se folosește o
      coadă, iar pentru a stabili dacă un vârf a fost sau nu vizitat se
      foloseşte un vector caracteristic. Algoritmul este:
      <ul>
        <li>adaugăm în coadă vârful inițial și îl vizităm</li>
        <li>cât timp coada este nevidă</li>
        <ul>
          <li>extragem un element din coadă</li>
          <li>extragem un element din coadă</li>
          <li>eliminăm elementul din coadă</li>
        </ul>
      </ul>
      Dacă graful nu este conex, în urma parcurgerii nu se vor vizita toate vârfurile.
      <br>
      <b>Implementare C++:      </b><br>
      <script src="https://ideone.com/e.js/sxqU5M" type="text/javascript" ></script>
      <br /><br /><br /><br />
    </div>
    <div class="partial" data-path="./../partials/footer.html"></div>
  </body>
</html>
