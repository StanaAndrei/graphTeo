<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../mstyle.css" />
    <script src="../pscripts.js" defer></script>
    <script src="./../../mscripts/loader.js" defer></script>
    <!--math-->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@500&display=swap"
      rel="stylesheet"
    />
    <title>Document</title>
  </head>
  <body>
    <div class="partial" data-path="./../partials/header.html"></div>
    <div id="mySidenav" class="sidenav">
      <a href="javascript:void(0)" class="closebtn">&times;</a>
    </div>
    <div class="divOfBtn">
      <span>&#9776; </span>
    </div>
    <div class="bigt">Grafuri(neorientate)</div>
    <div id="main">
      Introducere:
      <br />
      Grafurile au numeroase aplicații în diverse domenii: proiectarea
      circuitelor electrice, determinarea celui mai scurt drum dintre două
      localități, rețelele sociale (ex. Facebook), etc. Primele rezultate legate
      de teoria grafurilor au fost obținute de matematicianul Leonard Euler, cel
      care a studiat Problema podurilor din Königsberg, din imaginea de mai jos.
      A demonstrat că problema nu are soluție, iar în onoarea lui o categorie
      specială de grafuri au fost numite grafuri euleriene.
      <br /><br /><br />
      <div class="subtitle">Terminologie</div>
      <br />
      Definiție: Se numește graf neorientat o pereche ordonată de mulțimi
      G=(X,U), unde: X este o mulțime finită și nevidă de elemente numite
      vârfuri sau noduri; U este o mulțime finită de submulțimi cu două elemente
      din X, numite muchii. Vom nota în continuare vârfurile cu valori între 1
      și n – unde n este număru de vârfuri din graf, iar muchiile cu [x,y] sau
      (x,y), unde x și y sunt vârfuri și se numesc extremitățile muchiei. Un
      vecin al unui vârf x este orice vârf y cu proprietatea că există muchia
      [x,y]. Două vârfuri între care există muchie se numesc adiacente. Două
      muchii sunt incidente dacă au o o extremitate comună. Un vârf este
      incident cu o muchie dacă vârful este extremitate a acelei muchii.
      Mulțimea muchiilor are proprietatea de simetrie: dacă [x,y] este muchie,
      atunci și [y,x] este muchie. Conform definiției: într-un graf neorientat
      nu există muchie de la un vârf la el însuși; intre două vârfuri distincte
      există cel mult o muchie.
      <i>
        <br />
        Exemplu: Fie G=(X,U), unde: X={1,2,3,4,5,6,7,8,9,10,11}
        U={[1,4],[1,5],[2,3],[2,8],[3,11],[4,5],[4,9],[7,10],[8,11]}
      </i>
      <br /><br />
      <img src="./../images/img1.png" width="300" height="300" />
      <div class="subtitle">Gradul unui vârf</div>
      <b>Definiție</b> Într-un graf neorientat se numește grad al unui vârf
      numărul de vârful adiacente cu acesta (sau numărul de muchii incidente cu
      acesta). Gradul unui vărf x se notează d(x) (degree).
      <br />
      <b>Observatii:</b>
      <ul>
        <li>
          un vârf cu gradul 0 se numește izolat. În graful de mai sus, vârful 6
          este izolat.
        </li>
        <li>
          un vârf cu gradul 1 se numește terminal. În graful de mai sus, vârful
          9 este vârf terminal.
        </li>
        <li>gradul maxim al unui vârf într-un graf cu n vârfuri este n-1.</li>
      </ul>
      <b>Teoremă:</b>
      Într-un graf neorientat, suma gradelor tuturor vârfurilor este dublul
      numărului de muchii.
      <b>Consecințe:</b>
      <ul>
        <li>Suma gradelor tuturor vârfurilor este număr par.</li>
        <li>
          Într-un graf neorientat, numărul de vârfuri de grad impar este
          întotdeauna par.
        </li>
      </ul>
      <div class="subtitle">Reprezentarea grafurilor neorientate</div>
      <b>1.Matricea de adiacență: </b><br />
      Pentru un graf neorientat G=(X,U) cu n vârfuri, matricea de adiacență este
      o matrice cu n linii și n coloane și elemente din {0,1}, cu:
      <math xmlns="http://www.w3.org/1998/Math/MathML">
        <msub>
          <mi>A</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>i</mi>
            <mo>,</mo>
            <mi>j</mi>
          </mrow>
        </msub>
        <mo>=</mo>
        <mrow>
          <mo>{</mo>
          <mtable columnalign="left left" rowspacing="4pt" columnspacing="1em">
            <mtr>
              <mtd>
                <mn>1</mn>
              </mtd>
              <mtd>
                <mstyle displaystyle="false" scriptlevel="0">
                  <mtext>dac&#x103;&#xA0;</mtext>
                </mstyle>
                <mo stretchy="false">[</mo>
                <mi>i</mi>
                <mo>,</mo>
                <mi>j</mi>
                <mo stretchy="false">]</mo>
                <mo>&#x2208;<!-- ∈ --></mo>
                <mi>U</mi>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mstyle displaystyle="false" scriptlevel="0">
                  <mtext>dac&#x103;&#xA0;</mtext>
                </mstyle>
                <mo stretchy="false">[</mo>
                <mi>i</mi>
                <mo>,</mo>
                <mi>j</mi>
                <mo stretchy="false">]</mo>
                <mo>&#x2209;<!-- ∉ --></mo>
                <mi>U</mi>
              </mtd>
            </mtr>
          </mtable>
          <mo fence="true" stretchy="true" symmetric="true"></mo>
        </mrow>
      </math>
      <br />
      Exemplu: <br />
      Pentru graful neorientat de mai jos avem următoarea matrice de adiacență:
      <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mi>A</mi>
        <mo>=</mo>
        <mrow>
          <mo>(</mo>
          <mtable
            columnalign="center center center center center"
            rowspacing="4pt"
            columnspacing="1em"
          >
            <mtr>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>1</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>1</mn>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>1</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>1</mn>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>1</mn>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>1</mn>
              </mtd>
              <mtd>
                <mn>1</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mn>1</mn>
              </mtd>
              <mtd>
                <mn>0</mn>
              </mtd>
            </mtr>
          </mtable>
          <mo>)</mo>
        </mrow>
      </math>
      <br /><br /><br />
      <img src="./../images/img2.JPG" alt="" width="300" height="300" />
      <br /><br />
      <b>2.Lista de muchii</b><br />
      Lista de muchii a unui graf neorientat reprezintă o mulțime ce conține
      toate muchiile din graf. Pentru graful de sus, lista de muchii este:
      U={[1,2],[1,5],[2,5],[4,5]} Pentru reprezentarea în memorie putem folosi:
      <ul>
        <li>un tablou unidimensional cu elemente de tip struct {int I,J;}</li>
        <li>două tablouri unidimensionale cu elemente de tip int</li>
        <li>o listă alocată dinamic</li>
        <li>etc.</li>
      </ul>
      <b>3.Liste de adiacențe (de vecini): </b><br />
      Pentru un graf neorientat cu G=(X,U) se va memora numărul de vârfuri n și
      apoi, pentru fiecare vârf x, lista vârfurilor adiacente cu x, adică a
      vârfurilor y cu proprietatea că există muchia [x,y]. Pentru graful de sus,
      listele de adiacență sunt: <br />
      1: 2 5 <br />
      2: 1 5 <br />
      3: vidă <br />
      4: 5 <br />
      5: 1 2 4 <br />
      La reprezentarea în memorie trebui avut în vedere că dimensiunile listelor
      de vecini sunt variabile. De aceea, este neeficientă utilizarea unor
      tablouri alocate static. Astfel, putem folosi:

      <ul>
        <li>un șir de n tablouri unidimensionale alocate dinamic;</li>
        <li>un șir de n vectori din STL;</li>
        <li>un șir de n liste simplu (dublu) înlănțuite alocate dinamic.</li>
      </ul>
      <div class="subtitle">Graf parțial. Subgraf. Graf complementar</div>
      <b>Definiție:</b> Fie G=(X, U) un graf neorientat. Se numeşte graf parțial
      al grafului G, graful neorientat G1=(X, U1), unde U1 ⊆ U. Din definiție
      rezultă:
      <ul>
        <li>
          Un graf parțial al unui graf neorientat G=(V,U), are aceeaşi mulțime
          de vârfuri ca şi G, iar mulțimea muchiilor este o submulțime a lui U
          sau chiar U.
        </li>
        <li>
          Fie G=(X, U) un graf neorientat. Un graf parțial al grafului G se
          obține păstrând vârfurile şi eliminând eventual nişte muchii (se pot
          elimina şi toate muchiile sau chiar nici una).
        </li>
      </ul>
      <b>Definiție:</b> Fie G=(X, U) un graf orientat. Se numeşte subgraf al
      grafului G graful neorientat G1=(X1,U1) unde X1 ⊆ X iar U1 conține toate
      arcele din U care au extremitățile în X1. <br />
      Din definiție rezultă: <br />
      Fie G=(X,U) un graf orientat. Un subgraf al grafului G, se obține ştergând
      eventual anumite vârfuri şi odată cu acestea şi muchiile care le admit ca
      extremitate (nu se pot şterge toate vârfurile deoarece s-ar obține un graf
      cu mulțimea vârfurilor vidă).
      <img src="./../images/img3.JPG" alt="" />
      <b>Teoremă:</b> Fie G un graf neorientat cu n vârfuri și m muchii. Atunci:
      <ul>
        <li>graful G admite 2^m grafuri parțiale;</li>
        <li>graful G admite 2^(n)–1 subgrafuri;</li>
        <li>graful G admite un unic graf complementar.</li>
      </ul>
      <div class="subtitle">
        Graf nul. Graf complet. Graf regulat. Graf bipartit
      </div>
      <b>Definiție:</b>
      Un graf neorientat se numește graf nul dacă mulțimea muchiilor este vidă.
      <br />
      Într-un graf nul toate vârfurile sunt izolate.
      <br />
      <b>Definiție:</b>
      Fie G=(X, U) un graf neorientat. Graful G se numește graf complet dacă
      oricare două vârfuri distincte ale sale sunt adiacente. Un graf complet cu
      n vârfuri se notează K<small>n</small>.
      <br />
      Exemplu: Graful următor este graful K<small>5</small>.
      <br /><br /><br />
      <img src="./../images/img4.JPG" alt="" />
      <br />
      Într-un graf complet cu n vârfuri sunt
      <math xmlns="http://www.w3.org/1998/Math/MathML">
        <msubsup>
          <mi>C</mi>
          <mi>n</mi>
          <mn>2</mn>
        </msubsup>
        <mo>=</mo>
        <mrow class="MJX-TeXAtom-ORD">
          <mfrac>
            <mrow class="MJX-TeXAtom-ORD">
              <mi>n</mi>
              <mo>&#x2217;<!-- ∗ --></mo>
              <mo stretchy="false">(</mo>
              <mi>n</mi>
              <mo>&#x2212;<!-- − --></mo>
              <mn>1</mn>
              <mo stretchy="false">)</mo>
            </mrow>
            <mn>2</mn>
          </mfrac>
        </mrow>
      </math>
      muchii și fiecare vârf are gradul n-1.
      <br />
      <b>Propoziție:</b><br />
      Sunt
      <math xmlns="http://www.w3.org/1998/Math/MathML">
        <msup>
          <mn>2</mn>
          <mrow class="MJX-TeXAtom-ORD">
            <mfrac>
              <mrow class="MJX-TeXAtom-ORD">
                <mi>n</mi>
                <mo>&#x2217;<!-- ∗ --></mo>
                <mo stretchy="false">(</mo>
                <mi>n</mi>
                <mo>&#x2212;<!-- − --></mo>
                <mn>1</mn>
                <mo stretchy="false">)</mo>
              </mrow>
              <mn>2</mn>
            </mfrac>
          </mrow>
        </msup>
      </math>
      grafuri neorientate distincte cu n vârfuri.
      <b>Definiție:</b>
      Un graf în care toate nodurile au acelaşi grad se numește graf regulat.
      <b>Exemplu:</b><br />
      Graful de mai jos este regulat. <br /><br />
      <img src="./../images/img5.JPG" alt="" />
      <br />
      <b>Definiţie:</b> <br />
      Un graf G=(X, U) se numește graf bipartit dacă există două mulţimi nevide
      A și B astfel încât X=A ∪ B, A ∩ B = ∅ şi orice muchie u a lui G are o
      extremitate în A iar cealaltă în B. Mulţimile A şi B formează o partiţie a
      lui X.
      <br />
      <b>Exemplu:</b>
      <br />Graful următor este bipartit. A={1,2,5,7} și B={3,4,6}.
      <br />
      <img src="./../images/img6.JPG" alt="" />
      <br />
      <b>Definiție:</b><br />
      Un graf bipartit G=(X,U) se numește bipartit complet dacă pentru oricare
      două vârfuri x∈A și y∈B, există în graf muchia [x,y]; adică [x,y]∈U.
      <br />
      <b>Exemplu:</b>
      <br />Graful următor este bipartit complet. <br />
      <img src="./../images/img7.JPG" alt="" />
      <div class="subtitle">Conexitate</div>
      <br />
      <b>Lanț, ciclu</b>
      <br /><b>Definiție:</b>
      Se numește lanț o succesiune de vârfuri L=[x1,x2,⋯xk] cu proprietatea că
      oricare două vârfuri consecutive sunt adiacente.
      <br />
      Se numește lanț o succesiune de vârfuri L=[x1,x2,⋯xk] cu proprietatea că
      oricare două vârfuri consecutive sunt adiacente.
      <br />
      <b>Definiție:</b>
      Se numește ciclu un lanț simplu în care primul vârf este identic cu
      ultimul. Dacă toate vârfurile sunt distincte, mai puțin primul și ultimul,
      se numește ciclu elementar. Lungimea unui ciclu este egală cu numărul de
      muchii din ciclu. Lungimea minimă a unui ciclu este 3. Un ciclu se numește
      par dacă lungimea sa este pară, respectiv impar în caz contrar. Un graf
      neorientat care nu conține niciun ciclu se numește aciclic.
      <br />
      <b>Exemple:</b>
      În graful de mai sus:
      <img src="./../images/img8.JPG" alt="" />
      <ul>
        <li>[2,4,1,3,5,7] este un lanț elementar</li>
        <li>[3,5,7,6,5,1] este un lanț neelementar, dar simplu</li>
        <li>[2,3,5,7,6,5,3,1] este un lanț compus</li>
        <li>[1,5,3,2,4,1] este un ciclu elementar</li>
        <li>[1,3,5,7,6,5,1] este un ciclu neelementar</li>
      </ul>
      <div class="subtitle">Graf conex. Componente conexe</div>
      <br />
      <b> Definiție: </b> Un graf neorientat se numește graf conex dacă pentru
      oricare două vârfuri x și y diferite ale sale, există cel puțin un lanț
      care le leagă, adică x este extremitatea inițială și y este extremitatea
      finală. Un graf cu un singur nod este, prin definiție, conex. Definiție:
      Se numește componentă conexă a unui graf G=(X,U) un subgraf H=(Y, V),
      conex, al lui G care are proprietatea că nu există nici un lanț în G care
      să lege un vârf din Y cu un vârf din X – Y. Subgraful H este conex și
      maximal cu această proprietate (dacă s-ar mai adăuga un vârf nu ar mai fi
      conex.) Un graf este conex dacă admite o singură componentă conexă. <br />
      Graful următor este conex: <br /><br />
      <img src="./../images/img9.JPG" alt="" />
      <br /><br />
      Graful următor nu este conex și are 4 componente conexe. <br />
      <br />
      <img src="./../images/image10.JPG" alt="" />

      <div class="subtitle">Arbore. Pădure</div>
      <b>Definiție:</b>
      Se numește arbore un graf conex și aciclic.
      <b>Exemplu</b>
      Graful următor este arbore:
      <br /><br />
      <img src="./../images/img11.JPG" alt="" />
      <br />
      <b>Observații:</b><br />
      <ul>
        <li>Un arbore cu n vârfuri are n-1 muchii.</li>
        <li>
          Un arbore este un graf conex și minimal cu această proprietate; dacă
          s-ar mai elimina o muchie, graful nu ar mai fi conex.
        </li>
        <li>
          Un arbore este un graf aciclic și maximal cu această proprietate; dacă
          s-ar mai adăuga o muchie, s-ar obține un ciclu.
        </li>
      </ul>
      Un graf parțial care este arbore se numește arbore parțial. Un graf care
      nu conține cicluri se mai numește pădure. Într-o pădure fiecare componentă
      conexă este arbore.
      <div class="subtitle">Graf hamiltonian. Graf eulerian</div>
      <b>Definiție:</b>
      Se numește graf hamiltonian un graf care conține un ciclu hamiltonian. Se
      numește ciclu hamiltonian un ciclu elementar care conține toate vârfurile
      grafului.
      <br />
      Exemplu: Graful următor este hamiltonian. Un ciclu hamiltonian este:
      [1,4,2,3,7,6,5,1]
      <br />
      <img src="./../images/img12.JPG" alt="" />
      <br />
      <b>Teoremă:</b>
      Un G un graf neorientat. Dacă are n≥3 vârfuri şi gradul oricărui vârf
      verifică inegalitatea d(x)≥n/2 atunci G este hamiltonian.
      <br /><b>Definiție:</b> Se numește graf eulerian un graf care conține un
      ciclu eulerian. Se numește ciclu eulerian un ciclu care conține toate
      muchiile grafului. <br />
      Graful următor este eulerian. Un ciclu eulerian este:
      [1,4,2,1,3,2,7,3,5,7,6,5,1] <br />
      <img src="./../images/img13.JPG" alt="" /> <br />
      <b>Teoremă:</b>
      <br />Un graf G = (X,U), fără vârfuri izolate, este eulerian dacă şi numai
      dacă este conex şi gradele tuturor vârfurilor sale sunt numere pare.
      <br />
      <div class="bigt" id="grori">Grafuri orientate</div>
      <br />
      Se numeşte graf orientat sau digraf o pereche ordonată de mulțimi notată
      G=(V, U), unde:
      <br />
      V este o mulțime finită şi nevidă ale cărei elemente se numesc noduri sau
      vârfuri, U este o mulțime de perechi ordonate de elemente distincte din V
      ale cărei elemente se numesc arce;
      <br />
      <img src="./../images/img14.JPG" alt="" />
      <br />
      <b>Notiuni:</b>
      <ul>
        <li>
          extremități ale unui arc: pentru arcul u=(x,y), se numesc extremități
          ale sale nodurile x şi y;
          <ul>
            <li>x se numeşte extremitate inițială;</li>
            <li>y se numeşte extremitate finală;</li>
            <li>y se numește succesor al lui x;</li>
            <li>x se numește predecesor al lui y.</li>
          </ul>
        </li>
        <li>
          vârfuri adiacente: dacă într-un graf există arcul u=(x,y) (sau
          u=(y,x), sau amândouă), se spune despre nodurile x şi y că sunt
          adiacente;
        </li>
        <li>
          incidență:
          <ul>
            <li>
              dacă u1 şi u2 sunt două arce ale aceluiaşi graf, se numesc
              incidente dacă au o extremitate comună. Exemplu: u1=(x,y) şi
              u2=(y,z) sunt incidente;
            </li>
            <li>
              dacă u1=(x,y) este un arc într-un graf, se spune despre el şi
              nodul x, sau nodul y, că sunt incidente.
            </li>
          </ul>
        </li>
      </ul>
      <div class="subtitle">Grade</div>
      <br />
      <b>Definiție:</b>
      Fie G=(V, U) un graf orientat și x un nod al său. <br />
      <ul>
        <li>
          Se numeşte grad exterior al nodului x, numărul arcelor de forma (x,y)
          (adică numărul arcelor care ies din x), notat d+(x).
        </li>
        <li>
          Se numeşte grad interior al nodului x, numărul arcelor de forma (y,x)
          (adică numărul arcelor care intră în x), notat d-(x).
        </li>
      </ul>
      <img src="./../images/img15.JPG" alt="" />
      <br />
      Pentru graful de sus: d+(2)=2, d-(2)=3
      <div class="subtitle">Graf complet. Graf turneu.</div>
      <br />
      Fie G=(V, U) un graf orientat. Graful G se numește graf complet dacă
      oricare două vârfuri distincte ale sale sunt adiacente. <br />
      Două vârfuri x și y sunt adiacente dacă:

      <ul>
        <li>între ele există arcul (x,y), sau</li>
        <li>între ele există arcul (y,x), sau</li>
        <li>între ele există arcele (x,y) şi (y,x).</li>
      </ul>
      <br />
      <img src="./../images/img16.JPG" alt="" />
      <br />
      <b>Teoremă:</b>
      Numărul de grafuri orientate complete cu n noduri este 3^n*(n-1)/2.
      <b>Definiție:</b> Un graf orientat este turneu, dacă oricare ar fi două
      vârfuri i şi j, i≠j, între ele există un singur arc: arcul (i,j) sau arcul
      (j,i).
      <br />
      <img src="./../images/img17.JPG" alt="" />
      <b>Proprietăți:</b>
      <ul>
        <li>Orice graf turneu este graf complet.</li>
        <li>TeAvem 2^n*(n-1)/2 grafuri turneu cu n noduri.a</li>
        <li>
          În orice graf turneu există un drum elementar care trece prin toate
          vârfurile grafului.
        </li>
      </ul>
      <div class="subtitle">Conexitate</div>
      <div class="subtitle">*Lanț. Drum</div>
      Definiție: Fie G=(V, U) un graf orientat. Se numește lanț, în graful G, o
      succesiune de arce, notată L = (u1 , u2 ,..., uk) cu proprietatea ca
      oricare două arce consecutive au o extremitate comună (nu are importanță
      orientarea arcelor). sau Definiție: Fie G=(V, U) un graf orientat. Se
      numește lanț, în graful G, o succesiune de noduri, notată L = (x1 , x2
      ,..., xp) cu proprietatea ca oricare două noduri consecutive sunt
      adiacente. Lungimea unui lanț este egală cu numărul de arce din care este
      alcătuit. Primul nod și ultimul nod dintr-un lanț formează extremitățile
      lanțului. Definiție. Fie G=(V, U) un graf orientat. Se numește drum în
      graful G o succesiune de noduri, notată D = (x1 , x2 ,..., xk), cu
      proprietatea că pentru orice 1 ≤ i &lt k, (xi,xi+1) este arc în G.
      Lungimea unui drum este egală cu numărul de arce din care este alcătuit.
      Pentru un drum D = (x1 , x2 ,..., xk), nodurile x1 și xk reprezintă
      extremitățile – inițială, respectiv finală. Un lanț (drum) se numește
      elementar dacă în el nu se repetă noduri. Un lanț (drum) se numește simplu
      dacă în el nu se repetă arce.
      <div class="subtitle">*Circuit:</div>
      Se numește circuit un drum simplu în care extremitatea inițială și finală
      sunt egale. Se numește circuit elementar un circuit în care, cu excepția
      extremităților, nu se repetă noduri. Lungimea unui circuit este
      reprezentată de numărul de arce din care acesta este alcătuit.
      <br />
      <div class="subtitle">Conexitate. Tare conexitate</div>
      Definiții: Fie G=(V,U) un graf orientat. Graful se numește tare conex dacă
      între oricare două noduri distincte există cel puțin un drum. Se numește
      componentă tare conexă un subgraf tare conex și maximal cu această
      calitate – dacă am mai adauga un nod, n-ar mai fi tare conex. Observație:
      Un nod al grafului face parte dintr-o singură componentă tare conexă. Dacă
      ar face parte din două compoennte tare conexe, ele s-ar “reuni” prin
      intermediul acelui nod.
      <div class="subtitle">Graf hamiltonian. Graf eulerian</div>
      Definiții: Fie un graf orientat G=(V,U). Un drum elementar care conține
      toate nodurile grafului se numește drum hamiltonian. Un circuit elementar
      care conține toate nodurile grafului se numește circuit hamiltonian. Un
      graf care conține un circuit hamiltonian se numește graf hamiltonian.

      <b> Definiții: </b>
      Fie un graf orientat G=(V,U). Un drum care conține toate arcele grafului
      se numește drum eulerian. Un circuit care conține toate arcele grafului se
      numește circuit eulerian. Un graf care conține un circuit eulerian se
      numește graf eulerian. Teoremă: Un graf fără noduri izolate este eulerian
      dacă și numai dacă este conex și pentru fiecare nod, gradul interior este
      egal cu cel exterior. Exemplu: Graful orientat de mai jos este eulerian.
      <br />
      <img src="./../images/img18.JPG" alt="" />
      <br />
      Graful de mai sus nu este tare conex. El conține trei componente tare
      conexe. <br />
      Observație: Un nod al grafului face parte dintr-o singură componentă tare
      conexă. Dacă ar face parte din două compoennte tare conexe, ele s-ar
      “reuni” prin intermediul acelui nod.
      <div class="subtitle">Graf hamiltonian. Graf eulerian</div>
      Definiții: Fie un graf orientat G=(V,U). Un drum elementar care conține
      toate nodurile grafului se numește drum hamiltonian. Un circuit elementar
      care conține toate nodurile grafului se numește circuit hamiltonian. Un
      graf care conține un circuit hamiltonian se numește graf hamiltonian.
      <br />
      Definiții: Fie un graf orientat G=(V,U). Un drum care conține toate arcele
      grafului se numește drum eulerian. Un circuit care conține toate arcele
      grafului se numește circuit eulerian. Un graf care conține un circuit
      eulerian se numește graf eulerian. Teoremă: Un graf fără noduri izolate
      este eulerian dacă și numai dacă este conex și pentru fiecare nod, gradul
      interior este egal cu cel exterior. <br />
      <div class="bigt">Parcurgerea în adâncime</div>
      <br />
      Parcurgerea în adâncime reprezintă explorarea “naturală” a unui graf
      neorientat. Este foarte asemănătoare cu modul în care un turist vizitează
      un oraș în care sunt obiective turistice (vârfurile grafului) și căi de
      acces între obiective (muchiile). Vizitarea orașului va avea loc din
      aproape în aproape: se pleacă de la un obiectiv de pornire, se continuă cu
      un obiectiv învecinat cu acesta, apoi unul învecinat cu al doilea, etc.
      Parcurgerea în adâncime se face astfel:
      <ul>
        <li>
          Se începe cu un vârf inițial x, care este în acest moment vârf curent.
        </li>
        <li>
          Vârful x se vizitează. Se determină primul său vecin nevizitat y al
          lui x, care devine vârf curent.
        </li>
        <li>
          Apoi se vizitează primul vecin nevizitat al lui y, şi aşa mai departe,
          mergând în adâncime, până când ajungem la un vârf care nu mai are
          vecini nevizitați. Când ajungem într-un astfel de vârf, ne întoarcem
          la “părintele” acestuia – vârful din care am ajuns în acesta.
        </li>
        <li>
          Dacă acest vârf mai are vecini nevizitați, alegem următorul vecin
          nevizitat al său și continuam parcurgerea în același mod.
        </li>
        <li>
          Dacă nici acest vârf nu mai are vecini nevizitați, revenim în vârful
          său părinte și continuăm în același mod, până când toate vârfurile
          accesibile din vârful de start sunt vizitate.
        </li>
      </ul>
      Pentru implementarea algoritmului se foloseşte un vector caracteristic
      pentru memorarea faptului că un anume vârf a fost sau nu vizitat, la un
      anumit moment al parcurgerii: Pentru a determina ordinea în care se
      parcurg nodurile care pot fi vizitate, se folosește o stivă: Pentru
      implementare se poate folosi ca stivă memoria STACK, prin intermediul
      recursivității.
      <br />
      <b>Implementare C++: </b>
      <script
        src="https://ideone.com/e.js/9llxQr"
        type="text/javascript"
      ></script>
      <br />
      <div class="bigt">Parcurgerea în lățime</div>
      Se parcurge vârful de start, apoi vecinii acestuia, apoi vecinii
      nevizitați ai acestora, etc, până când sunt vizitate toate vârfurile
      accesibile. Practic, pentru a stabili ordinea de vizitare se folosește o
      coadă, iar pentru a stabili dacă un vârf a fost sau nu vizitat se
      foloseşte un vector caracteristic. Algoritmul este:
      <ul>
        <li>adaugăm în coadă vârful inițial și îl vizităm</li>
        <li>cât timp coada este nevidă</li>
        <ul>
          <li>extragem un element din coadă</li>
          <li>extragem un element din coadă</li>
          <li>eliminăm elementul din coadă</li>
        </ul>
      </ul>
      Dacă graful nu este conex, în urma parcurgerii nu se vor vizita toate
      vârfurile.
      <br />
      <b>Implementare C++: </b><br />
      <script
        src="https://ideone.com/e.js/sxqU5M"
        type="text/javascript"
      ></script>
      <div class="bigt">Tare conexitate</div>
      Un graf orientat G=(V,E) este tare conex dacă pentru orice pereche de
      noduri distincte (x,y) există cel puțin un drum de la x la y și există cel
      puțin un drum de la y la x.
      <br />
      <div class="subtitle">
        Verificarea tare conexității. Determinarea componentelor tare conexe
      </div>
      Verificare tare conexității unui graf orientat poate fi privită ca un caz
      particular al determinării componentelor tare conexe, deoarece, dacă
      graful are o singură componentă tare conexă atunci el este tare conex. În
      continuare vom vedea două metode de determinare a componentelor tare
      conexe. Ambele folosesc noțiunea de graf transpus, pe care o definim în
      continuare: Definiție: Fie G=(V,E) un graf orientat. Se numește graf
      transpus al lui G graful orientat GT=(V,ET), cu aceleași mulțimea a
      nodurilor și pentru orice pereche de noduri are loc: (x,y) este arc în G
      dacă și numai dacă (y,x) este arc în GT.
      <div class="subtitle">Algoritmul Plus-Minus</div>
      Pentru fiecare nod x al grafului care încă nu a fost plasat într-o
      componentă tare conexă:
      <ul>
        <li>
          determinăm toate nodurile în care se poate ajunge din x, folosind
          graful G și le marcăm într-un tablou cu plus;
        </li>
        <li>
          determinăm toate nodurile din care se poate ajunge în x, folosind
          graful GT și le marcăm într-un tablou cu minus;
        </li>
        <li>
          nodurile marcate atât cu plus, cât și cu minus, împreună cu x formează
          o componentă tare conexă;
        </li>
      </ul>
      <b>Secvență C++:</b>
      <ul>
        <li>n, a[][] – numărul de noduri și matricea de adiacență</li>
        <li>nrc – numărul de componente tare conexe</li>
        <li>
          ctc[] – tablou pentru memorarea componentelor tare conexe: ctc[i] =
          numărul de ordine al componentei din care face parte nodul i
        </li>
        <li>
          s[], p[] – tablouri pentru marcare nodurilor vizitate în timpul
          parcurgerilor
        </li>
        <li>
          să observăm că graful inițial și cel transpus pot fi memorate prin
          aceeași matrice de adiacență
        </li>
      </ul>
      <script
        src="https://ideone.com/e.js/m6ntQl"
        type="text/javascript"
      ></script>
      <div class="subtit">Algoritmul lui Kosaraju</div>
      Alt algoritm, mai eficient, pentru determinarea componentelor tare conexe
      este Algoritmul lui Kosaraju. Să ne amintim că la parcurgerea în adâncime
      se pot asocia nodurilor două momente de timp: *d[x] – momentul când nodul
      x este descoperit și adăugat pe stivă: timpul de descoperire a nodului
      *f[x] – momentul când se termină de vizitat succesorii lui x, iar nodul x
      se elimină de pe stivă: timpul de finalizare a nodului Aceste momente de
      timp vor fi numere naturale între 1 și 2*n, unde n este numărul de noduri
      din graf. Algoritmul lui Kosaraju este: determinăm graful transpus GT:
      parcurgem în adâncime graful și determinăm pentru fiecare nod x timpul de
      finalizare f[x] apoi parcurgem în adâncime graful transpus GT, dar
      considerăm nodurile în ordinea descrescătoarea timpilor de finalizare apoi
      nodurile din arborii de parcurgere obținuți reprezintă câte o componentă
      tare conexă.
      <b>Secvență C++: </b>
      <script
        src="https://ideone.com/e.js/cV7wpj"
        type="text/javascript"
      ></script>
      Fie G=(V,U) un graf orientat cu n noduri. Algoritmul Roy-Warshall
      construiește matricea drumurilor: D cu n linii și n coloane, în care:
      <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
        <msub>
          <mi>D</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>i</mi>
            <mo>,</mo>
            <mi>j</mi>
          </mrow>
        </msub>
        <mo>=</mo>
        <mrow>
          <mo>{</mo>
          <mtable
            columnalign="left left"
            rowspacing=".2em"
            columnspacing="1em"
            displaystyle="false"
          >
            <mtr>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mtext>dac&#x103;&#xA0;</mtext>
                <mi>i</mi>
                <mo>=</mo>
                <mi>j</mi>
                <mtext>&#xA0;sau nu exist&#x103; drum de la&#xA0;</mtext>
                <mi>i</mi>
                <mtext>&#xA0;la&#xA0;</mtext>
                <mi>j</mi>
                <mo>,</mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mn>1</mn>
              </mtd>
              <mtd>
                <mtext>dac&#x103;&#xA0;</mtext>
                <mi>i</mi>
                <mo>&#x2260;<!-- ≠ --></mo>
                <mi>j</mi>
                <mtext>&#xA0;&#x219;i exist&#x103; drum de la&#xA0;</mtext>
                <mi>i</mi>
                <mtext>&#xA0;la&#xA0;</mtext>
                <mi>j</mi>
              </mtd>
            </mtr>
          </mtable>
          <mo fence="true" stretchy="true" symmetric="true"></mo>
        </mrow>
      </math>
      Conform definiției de mai sus, în matricea drumurilor, elementele cu
      indici egali vor avea întotdeauna valoarea 0. Alternativ, putem accepta și
      elemente Di,i=1, înțelegând prin asta că există un circuit care conține
      nodul i. Pentru a construi această matrice, se pornește de la matricea de
      adiacență și i se aplică o serie de transformări, pornind de la următoarea
      idee: dacă nu există drum de la i la j, dar există drum de la i la k și
      drum de la k la j, atunci va exista și drum de la i la j, prin reuniunea
      celor două drumuri existente.
      <br />
      Mai exact:
      <ul>
        <li>
          inițial avem numai drumurile care nu au noduri intermediare (arcele)
        </li>
        <li>
          determinăm toate drumurile care îl au eventual ca nod intermediar pe 1
        </li>
        <li>
          determinăm toate drumurile care au noduri intermediare numai din
          mulțimea {1,2}
        </li>
        0
        <li>
          determinăm toate drumurile care au noduri intermediare numai din
          mulțimea {1,2,3}...
        </li>
        <li>
          pentru un k oarecare, determinăm toate drumurile care au noduri
          intermediare numai din mulțimea {1,2,…,k}. Pentru aceasta, vom căuta
          toate perechile de noduri i,j astfel încât Di,k=1 și Dk,j=1, de unde
          va rezulta că și Di,j=1.
        </li>
      </ul>
      <b>Secvența C++ </b>
      Secvență C++ – elementele de pe diagonală rămân 0:
      <br />
      <script
        src="https://ideone.com/e.js/TBROm4"
        type="text/javascript"
      ></script>
      Următoarea versiune transformă în 1 și elementele de pe diagonală care
      corespund unor noduri care fac parte din cel puțin un circuit.
      <br />
      <script
        src="https://ideone.com/e.js/GNS3nG"
        type="text/javascript"
      ></script>
      <div class="subtitle">Drumuri de cost minim într-un graf orientat</div>
      Fie G=(V,U) un graf orientat ponderat – în care fiecare arc are asociată o
      valoare reală numită pondere sau cost, de regulă pozitivă, cu noduri
      numerotate de la 1 la n. Se dorește determinarea pentru fiecare pereche de
      noduri x y, dacă există, a unui drum de cost minim – în care suma
      costurilor asociate arcelor care definesc drumul este minimă. Algoritmul
      pornește matricea costurilor , A – în care: <br />
      <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
        <msub>
          <mi>A</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>i</mi>
            <mo>,</mo>
            <mi>j</mi>
          </mrow>
        </msub>
        <mo>=</mo>
        <mrow>
          <mo>{</mo>
          <mtable
            columnalign="left left"
            rowspacing=".2em"
            columnspacing="1em"
            displaystyle="false"
          >
            <mtr>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mtext>dac&#x103;&#xA0;</mtext>
                <mi>i</mi>
                <mo>=</mo>
                <mi>j</mi>
                <mo>,</mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mtext>costul arcului&#xA0;</mtext>
                <mo stretchy="false">(</mo>
                <mi>i</mi>
                <mo>,</mo>
                <mi>j</mi>
                <mo stretchy="false">)</mo>
              </mtd>
              <mtd>
                <mtext>&#xA0;dac&#x103; exist&#x103; arc de la&#xA0;</mtext>
                <mi>i</mi>
                <mtext>&#xA0;la&#xA0;</mtext>
                <mi>j</mi>
                <mo>,</mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mi mathvariant="normal">&#x221E;<!-- ∞ --></mi>
              </mtd>
              <mtd>
                <mtext>&#xA0;dac&#x103; nu exist&#x103; arc de la&#xA0;</mtext>
                <mi>i</mi>
                <mtext>&#xA0;la&#xA0;</mtext>
                <mi>j</mi>
              </mtd>
            </mtr>
          </mtable>
          <mo fence="true" stretchy="true" symmetric="true"></mo>
        </mrow>
      </math>
      În reprezentarea în memorie, ∞ va fi înlocuit cu o valoare numerică mare.
      În C++, aceasta poate fi INF = 0x3F3F3F3F, având următoarele avantaje:
      <ul>
        <li>
          INF se reprezintă în tipul int (pe 32 de biți cu semn) și este mai
          mare decât 1.000.000.000
        </li>
        <li>
          suma INF + INF nu depășește limita maximă a tipului int, deci nu va
          face overflow.
        </li>
      </ul>
      Prin algoritmul Roy-Floyd matricea va fi transformată, astfel încât la
      final va avea următoarea semnificație:

      <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
        <msub>
          <mi>D</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>i</mi>
            <mo>,</mo>
            <mi>j</mi>
          </mrow>
        </msub>
        <mo>=</mo>
        <mrow>
          <mo>{</mo>
          <mtable
            columnalign="left left"
            rowspacing=".2em"
            columnspacing="1em"
            displaystyle="false"
          >
            <mtr>
              <mtd>
                <mn>0</mn>
              </mtd>
              <mtd>
                <mtext>dac&#x103;&#xA0;</mtext>
                <mi>i</mi>
                <mo>=</mo>
                <mi>j</mi>
                <mo>,</mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mtext>costul minim al unui drum de la&#xA0;</mtext>
                <mi>i</mi>
                <mtext>&#xA0;la&#xA0;</mtext>
                <mi>j</mi>
              </mtd>
              <mtd>
                <mtext
                  >&#xA0;dac&#x103; exist&#x103; un asemenea drum&#xA0;</mtext
                >
                <mo>,</mo>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <mi mathvariant="normal">&#x221E;<!-- ∞ --></mi>
              </mtd>
              <mtd>
                <mtext>&#xA0;dac&#x103; nu exist&#x103; drum de la&#xA0;</mtext>
                <mi>i</mi>
                <mtext>&#xA0;la&#xA0;</mtext>
                <mi>j</mi>
              </mtd>
            </mtr>
          </mtable>
          <mo fence="true" stretchy="true" symmetric="true"></mo>
        </mrow>
      </math>
      <b>Secvență C++ </b>
      <script
        src="https://ideone.com/e.js/HcbJry"
        type="text/javascript"
      ></script>
      <br />
      <div class="bigt">Algoritmul lui Dijkstra</div>
      Algoritmul lui Dijkstra determină pentru un nod dat într-un graf orientat
      cu costuri costurile minime ale drumurilor care au acel nod ca extremitate
      inițială. Mai precis, pentru un nod s – sursă, algoritmul determină pentru
      orice nod x costul minim al unui drum de la s la x. Strategia algoritmului
      lui Dijkstra este una de tip Greedy: <br />
      <ul>
        <li>
          se menține un tablou d[], în care d[x] reprezintă costul minim curent
          (eventual infinit) al unui drum de la s la x;
        </li>
        <li>
          se menține o mulțime F de noduri k pentru care s-a determinat costul
          minim final d[k]
        </li>
        <li>
          inițial în F se adaugă doar nodul s, pentru care d[s]=0; pentru
          nodurile x adiacente cu s, d[x]=c[s,x], unde c[x,y] este costul
          arcului (x,y), iar pentru celelalte noduri costul d[] se inițializează
          cu INFINIT;
        </li>
        <li>în mod repetat:</li>
        <ul>
          <li>
            alegem un nod din afara mulțimii F, nodul k pentru care costul
            drumului d[k] este minim și finit;
          </li>
          <li>adăugăm nodul găsit k în F;</li>
          <li>
            pentru fiecare arc (k,x) cu x din afara mulțimii F stabilim dacă
            acest arc se îmbunătățește costul d[x] (arcul relaxează drumul);
          </li>
        </ul>
        <li>
          alegerea acestor noduri se termină când toate nodurile au fost
          adăugate în F (s-au determinat costurile drumurile de la s la fiecare
          nod al grafului) sau când nu mai există noduri x din afara mulțimii F
          pentru care d[x] este finit;
        </li>
      </ul>
      <b>Secvență C++ </b>
      <script
        src="https://ideone.com/e.js/8sMo4o"
        type="text/javascript"
      ></script>
      <div class="subtitle">Algoritmul lui Kruskal</div>
      Considerăm un graf neorientat ponderat (cu costuri) conex G. Se numește
      arbore parțial un graf parțial al lui G care este arbore. Se numește
      arbore parțial de cost minim un arbore parțial pentru care suma costurilor
      muchiilor este minimă. Dacă graful nu este conex, vorbim despre o pădure
      parțială de cost minim. Algoritmul lui Kruskal permite determinarea unui
      arbore parțial de cost minim (APM) într-un graf ponderat cu N noduri.
      <br />
      <b>Descrierea algoritmului </b>
      Pentru a determina APM-ul se pleacă de la o pădure formată din N
      subarbori. Fiecare nod al grafului reprezintă inițial un subarbore.
      Aceștia vor fi reuniți succesiv prin muchii, până când se obține un singur
      arbore (dacă graful este conex) sau până când acest lucru nu mai este
      posibil (dacă graful nu este conex).
      <ul>
        <li>se ordonează muchiile grafului crescător după cost;</li>
        <li>
          se analizează pe rând muchiile grafului, în ordinea crescătoare a
          costurilor;
        </li>
        <li>pentru fiecare muchie analizată:</li>
        <ul>
          <li>
            dacă extremitățile muchiei fac parte din același subarbore, muchia
            se ignoră
          </li>
          <li>
            dacă extremitățile muchiei fac parte din subarbori diferiți, aceștia
            se vor reuni, iar muchia respectivă face parte din APM.
          </li>
        </ul>
      </ul>
      <b>Secvență C++ </b>
      <script
        src="https://ideone.com/e.js/yTOCZj"
        type="text/javascript"
      ></script>
      <div class="bigt">Arbori cu rădăcină</div>
      <div class="subtitle">Arbore liber</div>
      Un arbore este un graf conex și aciclic. Se mai numește și arbore liber.
      Următoarele propoziții sunt adevărate:
      <ul>
        <li>Un arbore cu n vârfuri are n-1 muchii.</li>
        <li>
          Un arbore este un graf conex și minimal cu această proprietate; dacă
          s-ar mai elimina o muchie, graful nu ar mai fi conex.
        </li>
        <li>
          Un arbore este un graf aciclic și maximal cu această proprietate; dacă
          s-ar mai adăuga o muchie, s-ar obține un ciclu.
        </li>
        <li>
          Între oricare două vârfuri ale unui arbore există un lanț elementar
          unic.
        </li>
      </ul>
      <div class="subtitle">Arbori cu rădăcină</div>
      Pentru un arbore se poate stabili un nod special, numit rădăcină. Putem
      spune că “agățăm” arborele în rădăcină, iar restul nodurilor cad. Mai jos
      avem trei arbori cu rădăcină. Toți pornesc de la arborele de mai sus, dar
      diferă prin alegerea rădăcinii.
      <br /><img src="./../images/img19.JPG" alt="" /> <br />
      <b>Terminologie</b>
      Fie un arbore cu rădăcina r și x un nod în acest arbore. Atunci:se numește
      ascendent al lui x orice nod y, diferite de x, aflat pe lanțul de la
      rădăcină la x; rădăcina nu are ascendenți; rădăcina este ascendent pentru
      toate nodurile din arbore; dacă y este ascendent al lui x și există muchia
      (y,x), atunci y se numește ascendent direct al lui x sau tatăl lui x;
      rădăcina este singurul nod din arbore care nu are tată; un nod y este
      descendent al nodului x, diferit de y, dacă x aparține lanțului de la r la
      y; dacă în plus există muchia (x,y), atunci y este descendent direct sau
      fiu al lui x; un nod care nu are niciun descendent se numește frunză; două
      noduri care au același tată se numesc frați; lungimea unui lanț de la
      rădăcina arborelui la un nod x reprezintă nivelul sau adâncimea nodului x;
      lungimea maximă a unui lanț de la rădăcină la un nod al arborelui
      reprezintă înălțimea arborelui; un nod al arborelui împreună cu toți
      descendenții săi formează un subarbore;
      <br />
      <div class="subtitle">Reprezentarea arborilor</div>
      <b>Reprezentarea prin referințe descendente </b>
      <img src="./../images/img20.JPG" alt="" />
      Pentru fiecare nod al arborelui se memorează informații despre
      descendenții săi direcți. Este similară cu reprezentarea prin liste de
      adiacențe a grafurilor. Pentru arborele de mai sus avem: F[1]={7,10}
      F[2]={1,5} F[3]={2,9} F[4]={6} F[5]={4} F[6]={} F[7]={} F[8]={}
      F[9]={8,11} F[10]={} F[11]={12} F[12]={} <br />
      <div class="subtitle">Reprezentarea prin referințe ascendente</div>
      Pentru fiecare nod se memorează informații despre ascendenții direcți. Vom
      obține un vector de tați, în care:
      <ul>
        <li>t[r] = 0, unde r este rădăcina arborelui</li>
        <li>t[k] = tatăl nodului k</li>
      </ul>
      Pentru arborele de mai sus avem: <br />
      k_____1_2_3_4_5_6_7_8_9_10__1__12 <br />
      t[k]__2_3_0_5_2_4_1_9_3_1___9___11
      <div class="bigt">Păduri de mulțimi disjuncte
      </div>
      În unele situații se cere gruparea elementelor unei mulțimi date într-o colecție de submulțimi disjuncte. Pentru o astfel de colecție sunt importante următoarele operații:
      <ul>
        <li>stabilirea submulțimii din care face parte un anumit element
        </li>
        <li>pentru două elemente date, reuniunea submulțimilor din care fac parte aceste elemente
        </li>
      </ul>
      Pentru fiecare submulțime se stabilește un reprezentant – unul dintre elementele submulțimii. Fiecare element al submulțimii este asociat într-un anumit mod cu reprezentantul acesteia. În acest fel, operația de stabilire a submulțimii din care face parte un anumit element constă în simpla identificare a reprezentantului, iar operația de reuniune a două submulțimii constă în asocierea elementelor unei submulțimii cu reprezentantul celeilalte. Două elemente fac parte din aceeași submulțime dacă sunt asociate cu același reprezentant.
      <br>
      <b>Utilizări</b>
      Operațiile cu mulțimi disjuncte pot fi folosite pentru determinarea componentelor conexe ale unui graf, astfel:
      <ul>
        <li>inițial fiecare nod face parte din propria sa submulțime;
        </li>
        <li>pentru fiecare muchie (x,y) stabilim dacă x și y fac parte din submulțimi diferite, caz în care reunim cele două submulțimi;
        </li>
        <li>la final, fiecare submulțime reprezintă câte o componentă conexă a grafului dat.
        </li>
      </ul>
      O altă aplicație a acestor structuri de date este Algoritmul lui Kruskal pentru determinarea arborelui parțial de cost minim a unui graf neorientat cu costuri.
      <br><b>Păduri de mulțimi disjuncte
      </b>
      <br>
      O modalitate eficientă de gestionare a submulțimilor și a operațiilor cu acestea este utilizarea unor structuri arborescente (a unei păduri), numite pădure de mulțimi disjuncte, în care:
      <ul>
        <li>fiecare submulțime este reprezentată printr-un arbore cu rădăcină
        </li>
        <li>rădăcina fiecărui arbore este reprezentantul submulțimii
        </li>
        <li>operațiile se implementează astfel:
        </li>
        <ul>
          <li>stabilirea submulțimii din care face parte un anumit element constă de regulă în identificarea rădăcinii arborelui din care face parte
          </li>
          <li>reuniunea a două submulțimi constă în concatenarea arborilor: rădăcina unuia dintre arbore i se stabilește devine tată pentru rădăcina celuilalt
          </li>
        </ul>
      </ul>
      Gestionarea arborilor se poate face prin intermediul unui vector de tați:T[k] = 0, dacă k este rădăcină a unui arbore (și reprezentant al submulțimii corespunzătoare)
      ,T[k] = tatăl lui k în arborele din care face parte 
      <b>Implementare C++
      </b>
      <script src="https://ideone.com/e.js/8730VY" type="text/javascript" ></script>
      <b>Îmbunătățirea operațiilor
      </b>
      Această implementare a operațiilor poate conduce la arbori cu înălțime mare. Acest fapt are efect asupra operației de determinare a rădăcinii arborelui din care face parte un nod dat, care este cu atât mai rapidă cu cât lungimea lanțului de la nod la rădăcină este mai mică. În gestionarea pădurilor de mulțimi disjuncte se pot folosi două euristici care duc la complexitate aproape liniară în raport cu numărul total de operații:
      <ul>
        <li>reuniunea după rang – se va păstra pentru fiecare arbore o aproximare a dimensiunii sale, numită rang. La reuniunea a doi arbori, cel cu rangul mai mic va deveni subarbore al celui cu rangul mai mare. Dacă cei doi arbori au același rang, rangul arborelui obținut va crește cu o unitate;
        </li>
        <li>comprimarea drumului – în funcția de determinare a rădăcinii pentru un nod dat, modificăm tații nodurilor de pe lanțul spre rădăcină, astfel încât acestea să devină fii ai rădăcinii. Altfel spus, legăm nodurile direct de rădăcină.
        </li>
      </ul>
      <script src="https://ideone.com/e.js/i2uhJS" type="text/javascript" ></script>
      <br>
      <div class="subtitle">----------------------------------------</div>
      <br /><br /><br /><br />
    </div>
    <div class="partial" data-path="./../partials/footer.html"></div>
  </body>
</html>
